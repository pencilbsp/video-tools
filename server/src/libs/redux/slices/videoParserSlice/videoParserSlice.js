/* Core */
import { toast } from "sonner";
import merge from "lodash/merge";
import { createSlice } from "@reduxjs/toolkit";

/* Instruments */
import { trimFalsely } from "@/libs/validate";
import { parseFromUrl, addVideosToQueue, addVideoToQueue } from "./thunks";

const orders = ["desc", "asc"];
const localKey = "videoParserOptions";

function getOptions() {
    try {
        const value = localStorage.getItem(localKey);
        if (!value) throw new Error();

        const options = JSON.parse(value);
        return options;
    } catch (error) {
        return { skip: 0, withTrailer: false, withVip: true, order: "desc" };
    }
}

function saveOptions(options) {
    try {
        localStorage.setItem(localKey, JSON.stringify(options));
    } catch (error) {}
}

const initialState = {
    site: "",
    title: "",
    cookies: [],
    selected: [],
    videoList: [],
    order: "desc",
    status: "idle",
    orderBy: "name",
    options: getOptions(),
};

export const videoParserSlice = createSlice({
    name: "videoParser",
    initialState,
    // The `reducers` field lets us define reducers and generate associated actions
    reducers: {
        changeParserOptions(state, action) {
            state.options = action.payload;
            saveOptions(action.payload);
            toast.success("Đã lưu các tuỳ chỉnh phân tích");
        },

        requestSort(state, action) {
            if (state.videoList.length === 0) return;

            const { order, orderBy } = action.payload;
            if (!orders.includes(order)) return;

            const keys = Object.keys(state.videoList[0]);
            if (!keys.includes(orderBy)) return;

            state.videoList = state.videoList.sort((a, b) =>
                order === "desc" ? a[orderBy] - b[orderBy] : b[orderBy] - a[orderBy],
            );
        },

        select(state, action) {
            const index = state.selected.indexOf(action.payload);
            if (index > -1) state.selected.splice(index, 1);
            else state.selected.push(action.payload);
        },

        selectAll(state, action) {
            state.selected = action.payload ? state.videoList.map(({ vid }) => vid) : [];
        },

        rename(state, action) {
            const { videoId, name } = action.payload;
            const index = state.videoList.findIndex(({ vid }) => vid === videoId);
            if (index > -1) state.videoList[index].name = name;
        },

        applyOption(state, action) {
            state.videoList.forEach((video, index) => {
                if (state.selected.includes(video.vid)) {
                    state.videoList[index] = merge(state.videoList[index], trimFalsely(action.payload));
                }
            });

            toast.success(`Đã áp dụng các tuỳ chỉnh cho ${state.selected.length} video`);
        },

        modifyOption(state, action) {
            const { videoId, key, value } = action.payload;
            const index = state.videoList.findIndex(({ vid }) => vid === videoId);
            if (index > -1) state.videoList[index].options[key] = value;
        },

        updateCookie(state, action) {
            const { mode, cookie, ids } = action.payload;
            if (mode === "add" && cookie.site === state.site) {
                state.cookies.push({ id: cookie.id, name: cookie.name });
            }

            if (mode === "delete") {
                const cookieIds = state.cookies.map(({ id }) => id);
                ids.forEach((id) => {
                    const index = cookieIds.indexOf(id);
                    index > -1 && state.cookies.splice(index, 1);
                });
            }
        },
    },
    // The `extraReducers` field lets the slice handle actions defined elsewhere,
    // including actions generated by createAsyncThunk or in other slices.
    extraReducers: (builder) => {
        builder
            // parseFromUrl
            .addCase(parseFromUrl.pending, (state) => {
                state.status = "loading";
            })
            .addCase(parseFromUrl.fulfilled, (state, action) => {
                state.site = action.payload.site;
                state.title = action.payload.title;
                state.cookies = action.payload.cookies;
                state.videoList = action.payload.videoList;
                const videoIds = action.payload.videoList.map((e) => e.vid);
                state.selected = state.selected.filter((vid) => videoIds.includes(vid));

                state.status = "idle";
            })
            .addCase(parseFromUrl.rejected, (state, action) => {
                state.status = "idle";
                toast.error(action.payload);
            })

            // addVideosToQueue
            .addCase(addVideosToQueue.pending, (state) => {
                state.status = "loading";
            })
            .addCase(addVideosToQueue.fulfilled, (state) => {
                state.videoList = state.videoList.filter(({ vid }) => !state.selected.includes(vid));

                toast.success(`Đã thêm ${state.selected.length} video vào hàng chờ`);

                state.selected = [];
                state.status = "idle";
            })
            .addCase(addVideosToQueue.rejected, (state) => {
                state.status = "idle";
                toast.error(action.payload);
            })

            // addVideoToQueue
            .addCase(addVideoToQueue.pending, (state) => {
                state.status = "loading";
            })
            .addCase(addVideoToQueue.fulfilled, (state, action) => {
                state.videoList = state.videoList.filter(({ vid }) => vid !== action.payload);
                state.selected = state.selected.filter((vid) => vid !== action.payload);
                state.status = "idle";
                toast.success("Đã thêm 1 video vào hàng chờ");
            })
            .addCase(addVideoToQueue.rejected, (state, action) => {
                state.status = "idle";
                toast.error(action.payload);
            });

        //
    },
});
